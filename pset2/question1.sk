generator int exp(int myi, int myj, int[2] goal) {
	int t = ??;

	if (t == 0) {
		return {| 0 | 1 | -1 |};
	}

	if (t == 1) {
		return {| myi | myj |};
	}

	if (t == 2) {
		return goal[??];
	}

	int left = exp(myi, myj, goal);
	int right = exp(myi, myj, goal);

	if (t == 3) {
		return rect(left);
	}

	if (t == 4) {
		return left + right;
	}

	if (t == 5) {
		return left - right;
	}
}

int rect(int x) {
	if (x > 0) {
		return 1;
	}
	if (x < 0) {
		return -1;
	}
	return 0;
}

generator void prog(int N, int[2][N] obstacles, ref int myi, ref int myj, int[2] goal) {
	int tmpi = myi + exp(myi, myj, goal);
	int tmpj = myj + exp(myi, myj, goal);

	if (!hasObstacle(N, obstacles, tmpi, tmpj)) {
		myi = tmpi;
		myj = tmpj;
	}
}

harness void new_coordinates(int N, int[2][N] obstacles, ref int myi, ref int myj, int[2] goal) {
	int old_myi = myi;
	int old_myj = myj;

	prog(N, obstacles, myi, myj, goal);

	assume myi < N;
	assume myi >= 0;
	assume myj < N;
	assume myj >= 0;

	bit has_shifted = old_myi != myi || old_myj != myj;
	assert has_shifted == true;

	old_myi = old_myi > myi ? old_myi - myi : myi - old_myi;
	old_myj = old_myj > myj ? old_myj - myj : myj - old_myj;

	assert old_myi <= 1;
	assert old_myj <= 1;

	int m_distance = manhattan_distance(old_myi, old_myj, myi, myj);
	minimize(m_distance);
}

bit hasObstacle(int N, int[2][N] obstacles, int myi, int myj) {
	for (int k = 0; k < N; k++) {
		int pos_i = obstacles[k][0];
		int pos_j = obstacles[k][1];
		if (pos_i == myi && pos_j == myj) {
			return true;
		}
	}
	return false;
}

void control([int N], ref int myi, ref int myj, int[2][N] obstacles, int[2] goal) {
	new_coordinates(N, obstacles, myi, myj, goal);
}

int manhattan_distance(int src_i, int src_j, int dest_i, int dest_j) {
	int pos_i = src_i > dest_i ? src_i - dest_i : dest_i - src_i;
	int pos_j = src_j > dest_j ? src_j - dest_j : dest_j - src_j;
	return pos_i + pos_j;
}

harness void checker(int N, int[2][N] obstacles, ref int myi, ref int myj, int[2] goal) {
	// At most the agent has to take 24 moves.
	int bnd = ??;
	assert bnd < 24;
	assert bnd > 0;
	while (myi != goal[0] && myj != goal[1]) {
		control(N, myi, myj, obstacles, goal);
		bnd--;
		assert bnd >= 0;
	}

	//We look for the smaller number of steps.
	minimize(bnd);
}

void main() {
	int N = ??;
	assume N < 3;
	assume N >= 0;

	// Initial position of the agent.
	int myi = 0;
	int myj = 0;

	int[2] goal = {??, ??};
	assume goal[0] < N;
	assume goal[0] >= 0;
	assume goal[1] < N;
	assume goal[1] >= 0;

	int [2][N] obstacles;
	for (int i = 0; i < N; i++) {
		int pos_i = ??;
		int pos_j = ??;

		// There's no obstacle at the initial position.
		assume pos_i != 0;
		assume pos_j != 0;

		// Each obstacle is inside the boundaries.
		assume pos_i < N;
		assume pos_i >= 0;
		assume pos_j < N;
		assume pos_j >= 0;

		for (int j = 0; j < i; j++) {
			int dest_i = obstacles[j][0];
			int dest_j = obstacles[j][1];
			// For every pair of obstacles, the distance is at least 3.
			int m_distance = manhattan_distance(pos_i, pos_j, dest_i, dest_j);
			assume m_distance > 3;
		}

		// Assignment of the obstacle.
		obstacles[i][0] = pos_i;
		obstacles[i][1] = pos_j;
	}

	checker(N, obstacles, myi, myj, goal);
}



